# 완전탐색 > 모의고사 (Level 1)
문제 : https://programmers.co.kr/learn/courses/30/lessons/42840

## 문제 설명
수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.

- 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...
- 2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...
- 3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...

1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.

## 제한사항
- 시험은 최대 10,000 문제로 구성되어있습니다.
- 문제의 정답은 1, 2, 3, 4, 5중 하나입니다.
- 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.

## 입출력 예

| answers | return |
| --- | --- | 
| [1,2,3,4,5] | 1 |
| [1,3,2,4,2] | [1,2,3] |

____

> #### < Code : Python >
```python
def solution_mockTest(answers):
    answer = []
    _1st = [1, 2, 3, 4, 5]
    _2nd = [2, 1, 2, 3, 2, 4, 2, 5]
    _3rd = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]
    count = [0] * 3
    
    for i in range(len(answers)):
        if answers[i] == _1st[i % len(_1st)]:
            count[0] += 1
        if answers[i] == _2nd[i % len(_2nd)]:
            count[1] += 1
        if answers[i] == _3rd[i % len(_3rd)]:
            count[2] += 1
    
    max_count = max(count)
    for i in range(len(count)):
        if count[i] == max_count:
            answer.append(i+1)        
    
    return answer
```

## 문제 리뷰
- 수포자들이 문제를 찍는 방식은 일정한 패턴을 가지고 반복됨
- 각 수포자들의 패턴을 파악하여 리스트로 저장
- 패턴이 반복되기 때문에 정답 인덱스를 패턴의 길이만큼 % 연산한 수의 위치에 있는 답과 비교하여 정답이면 count + 1
- 가장 정답을 많이 맞춘 사람의 정답 개수를 파악하여 그만큼 맞춘 사람을 answer에 삽입